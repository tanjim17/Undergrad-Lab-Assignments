diff --git a/Makefile b/Makefile
index 09d790c..5f0e7cb 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_ps\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +218,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -248,7 +249,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c _ps.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
diff --git a/proc.c b/proc.c
index 806b1b1..8411884 100644
--- a/proc.c
+++ b/proc.c
@@ -6,6 +6,8 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "random.h"
+#include "pstat.h"
 
 struct {
   struct spinlock lock;
@@ -20,6 +22,34 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
+void getpinfo1(struct pstat* ps) {
+  acquire(&ptable.lock);
+	for(struct proc* p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+		const int idx = p - ptable.proc;
+    ps->inuse[idx] = p->state == UNUSED ? 0 : 1;
+    ps->tickets[idx] = p->tickets;
+		ps->pid[idx] = p->pid;
+		ps->ticks[idx] = p->ticks;
+	}
+	release(&ptable.lock);
+}
+
+int total_tickets;
+void setproctickets(struct proc* pp, int n)
+{
+  //cprintf("yo: %d %d\n", pp->pid, n);
+	total_tickets -= pp->tickets;
+	pp->tickets = n;
+	total_tickets += pp->tickets;
+}
+
+void settickets1(struct proc* pp, int n) {
+  //cprintf("yay: %d %d\n", pp->pid, n);
+  acquire(&ptable.lock);
+  setproctickets(pp, n);
+  release(&ptable.lock);
+}
+
 void
 pinit(void)
 {
@@ -200,6 +230,8 @@ fork(void)
   np->parent = curproc;
   *np->tf = *curproc->tf;
 
+  setproctickets(np, curproc->tickets);
+  //cprintf("abc\n");
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
@@ -261,6 +293,8 @@ exit(void)
     }
   }
 
+  setproctickets(curproc, 0);
+
   // Jump into the scheduler, never to return.
   curproc->state = ZOMBIE;
   sched();
@@ -295,6 +329,8 @@ wait(void)
         p->name[0] = 0;
         p->killed = 0;
         p->state = UNUSED;
+        p->ticks = 0;
+				setproctickets(p, 0);
         release(&ptable.lock);
         return pid;
       }
@@ -325,17 +361,36 @@ scheduler(void)
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+
+  acquire(&ptable.lock);
+	setproctickets(ptable.proc, 1);
+	release(&ptable.lock);
+
+  static _Bool have_seeded = 0;
+	const int seed = 1323;
+	if(!have_seeded) {
+		srand(seed);
+		have_seeded = 1;
+	}
+
   for(;;){
     // Enable interrupts on this processor.
     sti();
 
+    const int winning_ticket = rand() % (total_tickets + 1);
+		int ticket_count = 0;
+    //cprintf("new %d\n", winning_ticket);
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
 
+      ticket_count += p->tickets;
+      //cprintf("%d %d %d\n", p->pid, ticket_count, winning_ticket);
+      if(ticket_count < winning_ticket)
+        continue;
+
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
@@ -343,12 +398,16 @@ scheduler(void)
       switchuvm(p);
       p->state = RUNNING;
 
+			const int tickstart = ticks;
       swtch(&(c->scheduler), p->context);
+      p->ticks += ticks - tickstart;
+
       switchkvm();
 
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       c->proc = 0;
+      break;
     }
     release(&ptable.lock);
 
diff --git a/proc.h b/proc.h
index 1647114..a7204b4 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,8 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+	int ticks;
+	int tickets;
 };
 
 // Process memory is laid out contiguously, low addresses first:
@@ -56,3 +58,6 @@ struct proc {
 //   original data and bss
 //   fixed-size stack
 //   expandable heap
+struct pstat;
+void settickets1(struct proc* pp, int n);
+void getpinfo1(struct pstat* ps);
\ No newline at end of file
diff --git a/ps.c b/ps.c
new file mode 100644
index 0000000..b047332
--- /dev/null
+++ b/ps.c
@@ -0,0 +1,33 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "pstat.h"
+
+#define TEST_PROC_COUNT 3
+
+int main(int argc, char *argv[]) {
+  int pids[TEST_PROC_COUNT];
+  int ticket_count[TEST_PROC_COUNT] = {10, 20, 30};
+
+  for (int i = 0; i < TEST_PROC_COUNT; i++) {
+    if ((pids[i] = fork()) == 0) {
+      settickets(ticket_count[i]);
+      while(1);
+    }
+  }
+  sleep(100);
+
+  int parent_pid = getpid();
+  while(1) {
+    printf(1,"PID\tTicks\tTickets\n");
+    struct pstat pinfo = {0};
+    getpinfo(&pinfo);
+    for (int i = 0; i < NPROC; i++) {
+      if(pinfo.inuse[i] && pinfo.pid[i] > parent_pid) {
+        printf(1, "%d\t%d\t%d\n", pinfo.pid[i], pinfo.ticks[i], pinfo.tickets[i]);
+      }
+    }
+    sleep(500);
+  }
+  exit();
+}
\ No newline at end of file
diff --git a/pstat.h b/pstat.h
new file mode 100644
index 0000000..cb2bc88
--- /dev/null
+++ b/pstat.h
@@ -0,0 +1,14 @@
+#ifndef _PSTAT_H_
+
+#define _PSTAT_H_
+
+#include "param.h"
+
+struct pstat {
+  int inuse[NPROC];   // whether this slot of the process table is in use (1 or 0)
+  int tickets[NPROC]; // the number of tickets this process has
+  int pid[NPROC];     // the PID of each process
+  int ticks[NPROC];   // the number of ticks each process has accumulated
+};
+
+#endif // _PSTAT_H_
\ No newline at end of file
diff --git a/random.h b/random.h
new file mode 100644
index 0000000..cbd0915
--- /dev/null
+++ b/random.h
@@ -0,0 +1,40 @@
+#ifndef _RANDOM_H
+#define _RANDOM_H
+
+#include "types.h"
+
+#define PHI 0x9e3779b9
+
+static uint Q[4096], c = 362436;
+
+static void srand(uint x)
+{
+	int i;
+
+	Q[0] = x;
+	Q[1] = x + PHI;
+	Q[2] = x + PHI + PHI;
+
+	for (i = 3; i < 4096; i++)
+			Q[i] = Q[i - 3] ^ Q[i - 2] ^ PHI ^ i;
+}
+
+static uint rand(void)
+{
+	if(sizeof(unsigned long long) != 8){
+		return 0;
+	}
+	unsigned long long t, a = 18782LL;
+	static uint i = 4095;
+	uint x, r = 0xfffffffe;
+	i = (i + 1) & 4095;
+	t = a * Q[i] + c;
+	c = (t >> 32);
+	x = t + c;
+	if (x < c) {
+	    x++;
+	    c++;
+	}
+	return (Q[i] = r - x);
+}
+#endif
\ No newline at end of file
diff --git a/syscall.c b/syscall.c
index ee85261..d5afd9a 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,8 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_settickets(void);
+extern int sys_getpinfo(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +128,8 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_settickets]   sys_settickets,
+[SYS_getpinfo]   sys_getpinfo,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..da165ba 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_settickets 22
+#define SYS_getpinfo 23
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 0686d29..e4ebc1c 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -6,6 +6,7 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+#include "pstat.h"
 
 int
 sys_fork(void)
@@ -89,3 +90,22 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_settickets(void) {
+  int ticket_count;
+  argint(0, &ticket_count);
+  if (ticket_count < 1)
+    return -1;
+  settickets1(myproc(), ticket_count);
+  return 0;
+}
+
+int
+sys_getpinfo(void) {
+	struct pstat* ps;
+	if(argptr(0, (void*)&ps ,sizeof(*ps)) != 0)
+		return -1;
+  getpinfo1(ps);
+	return 0;
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..7f7df9c 100644
--- a/user.h
+++ b/user.h
@@ -1,5 +1,6 @@
 struct stat;
 struct rtcdate;
+struct pstat;
 
 // system calls
 int fork(void);
@@ -23,6 +24,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int settickets(int);
+int getpinfo(struct pstat*);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..bce13c0 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,5 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(settickets)
+SYSCALL(getpinfo)
